索引堆：一种非常常用的数据结构


堆可以用来实现优先队列，但是普通堆只支持元素的插入、弹出堆顶元素，却不支持删除堆内元素、修改元素等操作。

普通的数据结构+哈希表往往能够实现一些高效的功能，比如链表+哈希表构成LRU、LFU。
堆+哈希表构成索引堆，从而可以对堆中的每个元素执行修改、删除操作。

多路归并排序需要用到堆，普通堆足以应对，因为每次删除包含最小元素的那条链，然后把这条链的指针挪动一格，重新把这条链放入堆中。整个过程只涉及：删除堆顶、添加元素两个操作。

Dijstra算法求图中某点到其它点的最短路径，也需要用到优先队列。在这个过程中，需要更新堆内元素的值，所以涉及到修改元素操作。但是Dijstra算法有一个特点：数值只会越变越小，堆内元素的值是单调变化的。这种情况下，普通堆也可胜任。

有一种常见的错误如下：  
当使用优先队列时，比较函数访问的是优先队列之外的数组，这个数组我们不应该随意改写，否则会把这个堆搞乱，从而降低了优先队列的性能，出现莫名其妙的问题，因为归根结底，优先队列不能这么用。完善的解决方法就是使用索引堆。


此repo实现了三个版本的索引堆：
* 可删除元素的优先队列  
Java集合框架中提供的PriorityQueue是一个小顶堆，它有一个remove方法用来删除元素，但不幸的是，这个方法的复杂度是O（N）的。虽然如此，我们依旧可以利用此remove方法来实现update函数。即：更新元素=删除旧元素+插入新元素

* 包含重复元素的优先队列
为了允许update操作，我们可以把变量的每个版本都保存在堆中。使用version来标记堆中每个元素的版本号，这个版本号是对元素执行写操作时完成的。当堆中弹出元素时，如果版本号与最新版本号不一致，说明这个堆结点已经失效了，不作处理。这种方法的缺点就是可能会占用较多的空间。

* 使用平衡树
平衡树里面就包含最大值、最小值，还是那个公式：update=remove+insert，利用这个法则就可以在TreeSet的基础上轻松高效实现索引堆

* 手写堆（最佳方式）
用数组实现堆是一件非常简单的事情。我们只需要给堆添加上移、下移基本操作，其余函数就非常简单了。

最后说一个设计思想：要保证确定性，不要随机性。即便要随机性，也要确定的随机性。

例如：索引堆中最小元素不唯一，这时应该弹出哪个元素。如果随机弹出一个最小元素，则会导致索引堆的行为变得难以理解、不可预测。这时我们就可以优先弹出索引较小的元素。这样就消除了随机性，便于理解、便与测试。

即便要随机性，我们也要设置好随机数种子，这样是为了程序能够复现。当追查错误时，最可怕的事情莫过于错误时隐时现，这样我们就找不到症结，无从下手。一定要消除不确定性，让随机变得确定。

# 参考资料
https://www.cnblogs.com/dudududu/p/8574740.html
http://shmilyaw-hotmail-com.iteye.com/blog/2097513