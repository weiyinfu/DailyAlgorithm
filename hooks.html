<html>
<head>
    <meta charset="UTF-8">
</head>
<body>
<div id="app"></div>
</body>
<script>
    const G = {};//定义一个全局函数
    let R = [];//R表示全局定时任务

    function useState(initValue) {
        const f = arguments.callee.caller;//获取谁在调用useUpdate()
        if (!G[f]) {
            G[f] = {
                ma: [],//useState的变量列表
                ind: 0, //useState语句对应的下标
                total: 0//整个caller函数所包含的useState的个数
            };
        }

        let ind = (G[f].ind + 1);//当前下标
        let v = null;//当前值
        G[f].ind++;
        if (G[f].total) {
            //如果G[f].total不为空，则表明不是第一次渲染，这时应该让下标取模
            ind %= G[f].total;
            v = G[f][ind];
        } else {
            //如果G[f].total为空，表明是第一次渲染，则保存初始值
            G[f][ind] = initValue;
            v = initValue;
        }

        //在react中setValue是异步更新，目的是减少调用ui函数的次数，能够起到汇聚作用。
        function setValue(v) {
            R.push([() => {
                G[f][ind] = v;
            }, f])
        }

        return [v, setValue];
    }

    function ui() {
        //这条日志应该每一秒钟执行一次
        console.log('ui is called', new Date().toLocaleString())
        const [time, $time] = useState(new Date().toLocaleString());
        const [yesterday, $yesterday] = useState('');

        function f() {
            $time(new Date().toLocaleString());
            const now = new Date();
            now.setTime(now.getTime() - 3600 * 24 * 1000);
            $yesterday(now.toLocaleString())
        }

        setTimeout(f, 1000)
        //执行渲染函数
        document.querySelector('#app').innerHTML = `
        今天${time}
        昨天${yesterday}
        `
    }

    //render函数有框架执行，框架在调用函数的时候可以在函数的前面和后面做一些简单记录操作
    function render(f) {
        if (G[f]) {
            G[f].ind = 0;
        }
        f();
        G[f].total = G[f].ind;
    }

    function update() {
        const ma = {}
        for (let [func, uiFunc] of R) {
            func();
            ma[uiFunc] = uiFunc;
        }
        R = []
        for (let uiFunc of Object.values(ma)) {
            uiFunc();
        }
        setTimeout(update, 50)
    }

    setTimeout(update, 50)
    render(ui)
</script>
</html>
