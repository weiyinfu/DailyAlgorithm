LCA，即lowest common ancestor，最近公共祖先算法。在一个树中，寻找两个特点结点的最近公共祖先。  

如果输入查询只有一个，那么使用tarjan算法O(n)复杂度解决，n为树中结点个数。  
如果输入查询有很多个，那么对这个树中的每个结点做一下预处理，使用倍增算法。每个查询复杂度都是log(n)。    
如果输入的这个树已知是有序二叉树，则存在更快捷的O(depth)算法。  

# tarjan算法
最近公共祖先的特点是什么？A结点和B结点都已经访问过时，未退出的最后一个结点。  

使用中序遍历，访问每个结点的时候把结点入栈，处理完成之后把结点弹栈，当A、B两个结点都访问时，栈顶未被弹出的结点就是A和B的最近公共祖先。  

# 倍增算法
tarjan算法在处理查询较少的时候优势明显，但是当查询较多的时候性能较差。  
倍增算法使用了额外的存储空间，记录每个结点的+1，+2，+4，+8等祖先结点。每个结点记录了log(n)个祖先结点。  

当查询来临时，让两个结点一起搜寻祖先结点，谁的祖先结点远离根就让谁前进。
# 有序二叉树中的LCA
有序二叉树有它自身的特点，从而存在更优的算法。  
给定两个值p和q`（p<q）`，它们的LCA的数值一定是中序遍历中第一个大于p且小于q的值。

# 字符串视角的LCA算法
